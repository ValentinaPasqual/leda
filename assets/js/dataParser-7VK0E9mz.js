import{s as y,l as F}from"./universalFooter-BH0r178q.js";const p="/leda/";function w(e){const r=e.startsWith("/")?e.slice(1):e;return(p.endsWith("/")?p:p+"/")+r}const C={config:{datasetConfig:{multivalue_rows:{},fields:{}}},async init(){try{const e=await F();return e?(this.config=e,this.config.datasetConfig?(this.config.datasetConfig.multivalue_rows||(this.config.datasetConfig.multivalue_rows={}),this.config.datasetConfig.fields||(this.config.datasetConfig.fields={})):this.config.datasetConfig={multivalue_rows:{},fields:{}}):console.warn("loadConfiguration returned undefined or null, using default config"),this}catch(e){return console.error("Error loading configuration:",e),console.warn("Using default configuration due to error"),this}},async saveConfig(){try{return await y(this.config),console.log("Configuration saved successfully with updated fields"),!0}catch(e){return console.error("Error saving configuration:",e),!1}},async parseData(){try{const[e,r]=await Promise.all([fetch(w("data/references.tsv")),fetch(w("data/locations.tsv"))]),[c,f]=await Promise.all([e.text(),r.text()]),a=this.parseTsvToJson(c),t=this.parseTsvToJson(f),s=a.length>0?Object.keys(a[0]):[],l=t.length>0?Object.keys(t[0]):[],n={catalogue:s,geodata:l,all:[...new Set([...s,...l])]},o=this.config.datasetConfig.fields;JSON.stringify(o)!==JSON.stringify(n)?(this.config.datasetConfig.fields=n,console.log("Dataset fields updated:",this.config.datasetConfig.fields),await this.saveConfig()?console.log("Fields permanently saved to config file"):console.warn("Failed to save fields to config file")):console.log("Fields unchanged, no need to update config file");let g=null;if(s.includes("Location")&&l.includes("Location")?g="Location":s.includes("Titolo")&&l.includes("Titolo")&&(g="Titolo"),!g)return console.warn("No common join field found. Available fields:"),console.warn("Catalogue fields:",s),console.warn("Geodata fields:",l),this.processMultivalueFields([...a,...t]);console.log(`Using "${g}" as join field`);const i=[];return t.forEach(u=>{const v=a.filter(h=>h[g]===u[g]);v.length>0?v.forEach(h=>{const m={...h,...u};i.push(m)}):i.push(u)}),this.processMultivalueFields(i)}catch(e){return console.error("Error in parseData:",e),[]}},processMultivalueFields(e){var c,f;const r=((f=(c=this.config)==null?void 0:c.datasetConfig)==null?void 0:f.multivalue_rows)||{};return e.forEach(a=>{Object.keys(r).forEach(t=>{if(a[t]&&typeof a[t]=="string"){const s=r[t];a[t]=a[t].split(s).map(l=>l.trim())}})}),e},parseTsvToJson(e){var t;const r=e.trim().split(/\r?\n/),c=r[0].split("	").map(s=>s.trim()),f=((t=this.config)==null?void 0:t.aggregations)||{},a=Object.keys(f).filter(s=>f[s].type!=="range");return r.slice(1).map(s=>{const l=s.split("	"),n={};return c.forEach((o,d)=>{const i=(d<l.length?l[d]:"").replace(/\r/g,"").trim();if(i===""){a.includes(o)?n[o]="Non specificato":n[o]="";return}i.toLowerCase()==="true"?n[o]=!0:i.toLowerCase()==="false"?n[o]=!1:!isNaN(i)&&i.trim()!==""?o==="Location"||o==="Titolo"?n[o]=i:n[o]=Number(i):n[o]=i}),n})}},D=async()=>(await C.init(),C.parseData());export{D as p};
